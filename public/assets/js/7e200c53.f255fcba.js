"use strict";(self.webpackChunkgds_bootcamp=self.webpackChunkgds_bootcamp||[]).push([[5610],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),h=o,k=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return n?a.createElement(k,s(s({ref:t},p),{},{components:n})):a.createElement(k,s({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8729:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:3},s="1.1 Refreshing Changes",i={unversionedId:"frontend/RefreshingChanges",id:"frontend/RefreshingChanges",title:"1.1 Refreshing Changes",description:"As a user, I would like to see if my todo list has changed since the last time I checked, so that I can stay updated on my tasks.",source:"@site/docs/frontend/11-RefreshingChanges.md",sourceDirName:"frontend",slug:"/frontend/RefreshingChanges",permalink:"/docs/frontend/RefreshingChanges",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/11-RefreshingChanges.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"1.0 The Frontend",permalink:"/docs/frontend/TheFrontend"},next:{title:"1.2 Done When I Say So",permalink:"/docs/frontend/DoneWhenISaySo"}},l={},c=[{value:"Adding a button",id:"adding-a-button",level:2},{value:"Making it click",id:"making-it-click",level:2},{value:"Making Progress",id:"making-progress",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"11-refreshing-changes"},"1.1 Refreshing Changes"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"As a user, I would like to see if my todo list has changed since the last time I checked, so that I can stay updated on my tasks."),(0,o.kt)("p",{parentName:"blockquote"},"It would be awesome to also have a visual indication of the system working on my request. ^_^")),(0,o.kt)("p",null,"In this exercise, we will add a refresh button to the Todo application."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"adding-a-button"},"Adding a button"),(0,o.kt)("p",null,"Let's start by adding a button."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<Button type=\"button\" isOutline>\n  <span className='sgds-icon sgds-icon-refresh' />\n</Button>\n")),(0,o.kt)("p",null,"The button can be placed anywhere, we've decided to put it just above the table and to the right of the 'Submit' button."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<Row>\n  <Col is={10}>\n    <input className=\"input\" id='newTodoDescription' type='text' value={newTodoDescription}\n      onChange={(event) => { setNewTodoDescription(event.currentTarget.value) }} />\n  </Col>\n  <Col>\n    <Button isPrimary isLoading={false}>Submit</Button>\n  </Col>\n  <Col>\n    {/* insert button here */}\n  </Col>\n</Row>\n")),(0,o.kt)("p",null,"These Buttons are standard SGDS components and come in different styles! Check them out ",(0,o.kt)("a",{parentName:"p",href:"https://govtechsg.github.io/sgds-govtech-react/?path=/story/components--buttons"},"here"),"."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"making-it-click"},"Making it click"),(0,o.kt)("p",null,"When a button is ",(0,o.kt)("inlineCode",{parentName:"p"},"clicked"),", it fires the attached ",(0,o.kt)("inlineCode",{parentName:"p"},"onClick(event)")," handler.\nStart by defining a new callback:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const onRefreshClicked = useCallback(async () => {\n  console.log('Refresh button clicked');\n}, []);\n")),(0,o.kt)("p",null,"Then hook it up to the button:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<Button type=\"button\" isOutline onClick={/* insert callback function here */}>\n  <span className='sgds-icon sgds-icon-refresh' />\n</Button>\n")),(0,o.kt)("p",null,"When refresh is clicked, you should now see a log entry appear in the console!"),(0,o.kt)("p",null,"Instead of calling ",(0,o.kt)("inlineCode",{parentName:"p"},"console.log()"),", let's make it call ",(0,o.kt)("inlineCode",{parentName:"p"},"populateTodos"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const onRefreshClicked = useCallback(async () => {\n  console.log('Refresh button clicked');\n  await /* insert asynchronous network-bound function call here */\n  console.log('todoList updated');\n}, [populateTodos]);\n")),(0,o.kt)("p",null,"An ",(0,o.kt)("em",{parentName:"p"},"asynchronous")," function ",(0,o.kt)("inlineCode",{parentName:"p"},"populateTodos()")," is making a network call to our backend API to get the latest ",(0,o.kt)("inlineCode",{parentName:"p"},"todoList"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," keyword means that these statements will block, happening ",(0,o.kt)("em",{parentName:"p"},"sequentially")," one after another. That means that the second log entry is created only after the refresh is complete."),(0,o.kt)("p",null,"The dependencies array ",(0,o.kt)("inlineCode",{parentName:"p"},"[populateTodos]")," tells React to watch out for changes in ",(0,o.kt)("inlineCode",{parentName:"p"},"populateTodos"),". It's easy to get used to, and you'll see more of it later."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"making-progress"},"Making Progress"),(0,o.kt)("p",null,"Visual feedback is an important way of communicating with the user."),(0,o.kt)("p",null,"A progress indicator satisfies the user's need to know that the system received, and is processing, their request."),(0,o.kt)("p",null,"Start by adding a new piece of state to the Todo component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const [isRefresh, setIsRefresh] = useState(false);\n")),(0,o.kt)("p",null,"Creating state in this way is useful because React can 'hook' into every modification to the state and help keep track of what changed / needs to be rendered again."),(0,o.kt)("p",null,"When calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"useState()")," hook, React gives you a read-only variable (with the default parameter specified in the ",(0,o.kt)("inlineCode",{parentName:"p"},"useState<T>(default: T)")," call), and a setter you can call like this: ",(0,o.kt)("inlineCode",{parentName:"p"},"setIsRefresh(true)"),"."),(0,o.kt)("p",null,"Let's hook up the ",(0,o.kt)("inlineCode",{parentName:"p"},"isRefresh")," state to the button's progress indicator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<Button type=\"button\" isOutline isLoading={/* insert boolean refresh state here */} onClick={onRefreshClicked}>\n  <span className='sgds-icon sgds-icon-refresh' />\n</Button>\n")),(0,o.kt)("p",null,"When the button is clicked, it should set the loading indicator with ",(0,o.kt)("inlineCode",{parentName:"p"},"setIsRefresh(true)"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const [isRefresh, setIsRefresh] = useState(false);\nconst onRefreshClicked = useCallback( async () => {\n  /* start the refresh here */\n  setTimeout(async () => {\n    await populateTodos();\n    /* stop the refresh here */\n  }, 400);\n}, [populateTodos]);\n")),(0,o.kt)("p",null,"The refresh animation starts before starting the actual refresh operation. When the ",(0,o.kt)("inlineCode",{parentName:"p"},"await populateTodos()")," synchronously completes, the refresh animation stops."),(0,o.kt)("p",null,"On a local network, this refresh happens too quickly to be perceptible, so we're waiting a couple hundred milliseconds to ",(0,o.kt)("del",{parentName:"p"},"charge our capacitors")," queue up the request."))}u.isMDXComponent=!0}}]);